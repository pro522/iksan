<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- ì˜¤í”ˆ ê·¸ë˜í”„ -->
    <meta property="og:title" content="ìµœë³‘ê´€ì˜ ê·œì œ ê²©íŒŒ" />
    <meta property="og:description" content="ë‹µë‹µí•œ ê·œì œ, ìµœë³‘ê´€ê³¼ í•¨ê»˜ ì‹œì›í•˜ê²Œ ë‚ ë ¤ë²„ë¦¬ì„¸ìš”! ì¼ì¼ë„ì‹œ ìµì‚° ëŒ€ì „í™˜ í”„ë¡œì íŠ¸." />
    <meta property="og:image" content="./thumbnail.png" />
    <meta property="og:type" content="website" />

    <title>ìµœë³‘ê´€ì˜ ê·œì œ ê²©íŒŒ</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 3. Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. Firebase ë¼ì´ë¸ŒëŸ¬ë¦¬ (í˜¸í™˜ì„± ë²„ì „) -->
    <!-- ì°¸ê³ : ë¡œì»¬/GitHub í™˜ê²½ì—ì„œëŠ” Firebaseê°€ ë™ì‘í•˜ì§€ ì•Šì•„ë„ ë¡œì»¬ ì¹´ìš´í„°ë¡œ ìë™ ì „í™˜ë©ë‹ˆë‹¤. -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    
    <style>
        body {
            touch-action: none;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            background-color: #0f172a;
            color: white;
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            margin: 0; padding: 0;
            overflow: hidden;
        }
        .gradient-text {
            background: linear-gradient(to right, #facc15, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.5s ease-out forwards; }
        @keyframes countUp { 0% { transform: scale(1); } 50% { transform: scale(1.1); color: #facc15; } 100% { transform: scale(1); } }
        .animate-count { animation: countUp 0.3s ease-in-out; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // [ì„¤ì •] ì´ë¯¸ì§€ ê²½ë¡œ
        const CANDIDATE_IMG_PATH = "./candidate.png";

        // [ì„¤ì •] Firebase ì´ˆê¸°í™” (ì•ˆì „ ëª¨ë“œ)
        let db = null;
        let auth = null;
        let isFirebaseAvailable = false;
        let appId = 'iksan-campaign';

        try {
            if (typeof firebase !== 'undefined' && !firebase.apps.length) {
                const configRaw = window.__firebase_config;
                if (configRaw && configRaw.trim() !== '' && configRaw !== '{}') {
                    const config = JSON.parse(configRaw);
                    firebase.initializeApp(config);
                    db = firebase.firestore();
                    auth = firebase.auth();
                    appId = typeof window.__app_id !== 'undefined' ? window.__app_id : 'iksan-campaign';
                    isFirebaseAvailable = true;
                } else {
                    console.log("Firebase config not found. Local mode.");
                }
            }
        } catch(e) { 
            console.log("Firebase init skipped:", e); 
        }

        // --- Icons ---
        const Play = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>);
        const RotateCcw = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>);
        const Share2 = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>);
        const Zap = ({ className }) => (<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>);
        const Camera = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>);
        const CheckCircle = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>);
        const XCircle = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>);
        const ArrowRight = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>);
        const Target = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>);
        const User = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>);
        const Users = ({ className, size }) => (<svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>);

        // ==================================================================================
        // 1. INTRO SCREEN
        // ==================================================================================
        const IntroScreen = ({ onStart }) => {
            const [imgError, setImgError] = useState(false);
            const [visitorCount, setVisitorCount] = useState(0);

            useEffect(() => {
                let unsubscribe = null;

                const runLocalMode = () => {
                    // ì„œë²„ ì—°ê²° ì‹¤íŒ¨ ì‹œ: ë¡œì»¬ ì €ì¥ì†Œ ì¹´ìš´íŠ¸ (ì•ˆì „ì¥ì¹˜)
                    const saved = parseInt(localStorage.getItem('iksan_real_visits') || '0');
                    const nextCount = saved + 1;
                    setVisitorCount(nextCount);
                    localStorage.setItem('iksan_real_visits', nextCount.toString());
                };

                const initFirebaseLogic = async () => {
                    if (!isFirebaseAvailable || !auth || !db) {
                        runLocalMode();
                        return;
                    }

                    try {
                        if (window.__initial_auth_token) {
                            await auth.signInWithCustomToken(window.__initial_auth_token);
                        } else {
                            await auth.signInAnonymously();
                        }

                        const docRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('visitor_stats').doc('global_counter');

                        // ì¹´ìš´íŠ¸ ì¦ê°€
                        db.runTransaction(async (transaction) => {
                            const sfDoc = await transaction.get(docRef);
                            if (!sfDoc.exists) {
                                transaction.set(docRef, { count: 1 });
                            } else {
                                const newCount = (sfDoc.data().count || 0) + 1;
                                transaction.update(docRef, { count: newCount });
                            }
                        }).catch(err => {
                            runLocalMode();
                        });

                        unsubscribe = docRef.onSnapshot((snap) => {
                            if (snap.exists) {
                                setVisitorCount(snap.data().count || 0);
                            }
                        }, (error) => {
                            // ì½ê¸° ì‹¤íŒ¨ ì‹œ ë¡œì»¬ ëª¨ë“œ ì „í™˜ì€ ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬ë¨ (ë˜ëŠ” ê¸°ì¡´ ê°’ ìœ ì§€)
                        });

                    } catch (e) {
                        runLocalMode();
                    }
                };

                setTimeout(initFirebaseLogic, 500);
                return () => { if(unsubscribe) unsubscribe(); };
            }, []);

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-6 max-w-md mx-auto relative overflow-hidden animate-fade-in">
                    
                    {/* Visitor Count Badge */}
                    <div className="absolute top-4 right-4 bg-slate-800/80 text-yellow-400 px-3 py-1 rounded-full text-xs font-bold border border-yellow-500/30 flex items-center shadow-lg z-20">
                        <Users size={12} className="mr-1"/>
                        ì°¸ì—¬: {visitorCount > 0 ? visitorCount.toLocaleString() : "..."}ëª…
                    </div>

                    <div className="absolute top-0 left-0 w-full h-full opacity-10 pointer-events-none">
                        <div className="absolute top-10 left-10 w-32 h-32 bg-blue-500 rounded-full blur-3xl"></div>
                        <div className="absolute bottom-10 right-10 w-40 h-40 bg-yellow-500 rounded-full blur-3xl"></div>
                    </div>

                    <div className="text-center z-10 mb-8">
                        <div className="inline-block p-2 bg-blue-900/50 rounded-full border border-blue-500/30 mb-4 shadow-lg shadow-blue-500/20">
                            <span className="text-blue-300 text-xs font-bold px-2">ìµì‚° ëŒ€ì „í™˜ í”„ë¡œì íŠ¸</span>
                        </div>
                        <h1 className="text-4xl font-black mb-2 leading-tight">
                            ë‹µë‹µí•œ ê·œì œ,<br/>
                            <span className="gradient-text">í–‰ì •ì „ë¬¸ê°€</span>ê°€ ê¹¹ë‹ˆë‹¤!
                        </h1>
                        <p className="text-slate-400 text-sm">"ê·œì œëŠ” ì•„ëŠ” ì‚¬ëŒë§Œì´ ì œëŒ€ë¡œ ê¹° ìˆ˜ ìˆìŠµë‹ˆë‹¤."</p>
                    </div>

                    <div className="relative mb-10 group cursor-pointer" onClick={onStart}>
                        <div className="w-32 h-32 rounded-full border-4 border-yellow-400 shadow-[0_0_30px_rgba(250,204,21,0.3)] overflow-hidden bg-blue-600 relative z-10 flex items-center justify-center">
                            {!imgError ? (
                                <img 
                                    src={CANDIDATE_IMG_PATH} 
                                    alt="ìµœë³‘ê´€" 
                                    className="w-full h-full object-cover" 
                                    onError={() => setImgError(true)}
                                />
                            ) : (
                                <User size={64} className="text-white opacity-80" />
                            )}
                        </div>
                        <div className="absolute -bottom-3 -right-3 bg-red-500 text-white p-3 rounded-full shadow-lg z-20 animate-bounce">
                            <Play className="w-6 h-6" />
                        </div>
                    </div>

                    <div className="w-full bg-blue-900/30 p-5 rounded-2xl border border-blue-500/20 mb-8">
                        <h3 className="text-center font-bold text-blue-300 mb-4 flex items-center justify-center">
                            <Zap className="w-4 h-4 mr-2" /> 3ëŒ€ í•µì‹¬ ë¯¸ì…˜
                        </h3>
                        <ul className="space-y-2 text-sm text-slate-300">
                            <li className="flex items-center"><CheckCircle className="w-4 h-4 text-green-400 mr-2"/> ì†Œìƒê³µì¸ ë§¤ì¶œ 3ë°° ë‹¬ì„±</li>
                            <li className="flex items-center"><CheckCircle className="w-4 h-4 text-green-400 mr-2"/> ì²­ë…„ì´ ë¨¸ë¬´ëŠ” ì¼ì¼ë„ì‹œ</li>
                            <li className="flex items-center"><CheckCircle className="w-4 h-4 text-green-400 mr-2"/> êµ­ë¹„ ì˜ˆì‚° í­íƒ„ í™•ë³´</li>
                        </ul>
                    </div>

                    {/* [ìˆ˜ì •] ë²„íŠ¼ í™œì„±í™”: z-50ìœ¼ë¡œ ìµœìƒìœ„ ë°°ì¹˜, animate-pulse ì œê±°í•˜ì—¬ í´ë¦­ ê°€ëŠ¥í•´ ë³´ì´ê²Œ */}
                    <button 
                        onClick={onStart}
                        className="relative z-50 w-full bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 text-white font-black text-lg py-4 rounded-xl shadow-xl shadow-blue-600/30 active:scale-95 transition-all flex items-center justify-center group cursor-pointer"
                    >
                        <Play className="w-6 h-6 mr-2 group-hover:scale-110 transition-transform" />
                        ì§€ê¸ˆ ë°”ë¡œ ì¶œë™í•˜ê¸°
                    </button>

                    <p className="mt-6 text-xs text-slate-500 text-center">
                        ìµì‚°ì‹œì¥ ì˜ˆë¹„í›„ë³´ ìµœë³‘ê´€ | ì„ ê±°ìº í”„ ì „ëµê¸°íšì‹¤
                    </p>
                </div>
            );
        };

        // ------------------------------------------------------------
        // 2. GAME SCREEN (ìµœì í™” ë²„ì „)
        // ------------------------------------------------------------
        const GameScreen = ({ onBackToIntro }) => {
            const canvasRef = useRef(null);
            const candidateImageRef = useRef(null);
            
            // Config
            const WIDTH = 360;
            const HEIGHT = 640; 
            const CONTROL_HEIGHT = 100; 
            const GAME_HEIGHT = HEIGHT - CONTROL_HEIGHT; 
            const PADDLE_WIDTH = 80;
            const PADDLE_HEIGHT = 15;
            const BALL_RADIUS = 6;
            const BRICK_ROW_COUNT = 6;
            const BRICK_COL_COUNT = 5;
            const BRICK_PADDING = 10;
            const BRICK_OFFSET_TOP = 80;
            const BRICK_OFFSET_LEFT = 25;
            const BRICK_WIDTH = (WIDTH - (BRICK_OFFSET_LEFT * 2) - (BRICK_PADDING * (BRICK_COL_COUNT - 1))) / BRICK_COL_COUNT;
            const BRICK_HEIGHT = 30;

            const POLICY_LIST = [
                ["ì†Œìƒê³µì¸\në§¤ì¶œ3ë°°", "ê³¨ëª©ìƒê¶Œ\ní™œì„±í™”", "ì§€ì—­í™”í\ní™•ëŒ€"], 
                ["ì²­ë…„\nì¼ìë¦¬", "ìŠ¤íƒ€íŠ¸ì—…\níŒŒí¬", "ì£¼ê±°ì•ˆì •\nì§€ì›"],     
                ["êµ­ê°€ì‚°ë‹¨\nìœ ì¹˜", "KTXì—­ì„¸ê¶Œ\nê°œë°œ", "êµ­ë¹„ì˜ˆì‚°\ní­íƒ„"],  
            ];
            const STAGE_TITLES = ["ë¯¼ìƒ ì‚´ë¦¬ê¸°", "ì²­ë…„ê³¼ ë¯¸ë˜", "ìµì‚° ëŒ€ë„ì•½"];
            
            // Difficulty Settings
            const DIFFICULTY_SETTINGS = {
                EASY: { label: "ì‰¬ì›€", speed: 2, paddleWidth: 100, lives: 5, color: "bg-green-500", text: "text-green-400" },
                NORMAL: { label: "ë³´í†µ", speed: 3, paddleWidth: 80, lives: 3, color: "bg-blue-500", text: "text-blue-400" },
                HARD: { label: "ì–´ë ¤ì›€", speed: 5, paddleWidth: 60, lives: 2, color: "bg-red-500", text: "text-red-400" }
            };

            // Refs for Game State
            const gameStateRef = useRef('START');
            const scoreRef = useRef(0);
            const livesRef = useRef(3);
            const stageRef = useRef(1);
            const difficultyRef = useRef('NORMAL');
            const achievedPoliciesRef = useRef([]);

            // React State for UI updates
            const [uiState, setUiState] = useState({
                gameState: 'START',
                score: 0,
                lives: 3,
                stage: 1,
                difficulty: 'NORMAL',
                achievedPolicies: []
            });
            const [imageLoaded, setImageLoaded] = useState(false);
            const [resultImage, setResultImage] = useState(null);

            const paddleRef = useRef({ x: (WIDTH - 80) / 2, width: 80 });
            const ballRef = useRef({ x: WIDTH / 2, y: GAME_HEIGHT - 30, dx: 3, dy: -3, speedBase: 3, active: false });
            const bricksRef = useRef([]);
            const itemsRef = useRef([]);
            const particlesRef = useRef([]);
            const floatingTextsRef = useRef([]);
            const requestIdRef = useRef(null);

            // Sync Refs and State helper
            const updateGameState = (newState) => {
                gameStateRef.current = newState;
                setUiState(prev => ({ ...prev, gameState: newState }));
            };
            const updateScore = (newScore) => {
                scoreRef.current = newScore;
                setUiState(prev => ({ ...prev, score: newScore }));
            };
            const updateLives = (newLives) => {
                livesRef.current = newLives;
                setUiState(prev => ({ ...prev, lives: newLives }));
            };
            const updateStage = (newStage) => {
                stageRef.current = newStage;
                setUiState(prev => ({ ...prev, stage: newStage }));
            };
            const updateDifficulty = (newDiff) => {
                difficultyRef.current = newDiff;
                setUiState(prev => ({ ...prev, difficulty: newDiff }));
            };
            const addAchievedPolicy = (policy) => {
                if (!achievedPoliciesRef.current.includes(policy)) {
                    achievedPoliciesRef.current.push(policy);
                    setUiState(prev => ({ ...prev, achievedPolicies: [...achievedPoliciesRef.current] }));
                }
            };
            const forceUpdate = () => {
                setUiState({
                    gameState: gameStateRef.current,
                    score: scoreRef.current,
                    lives: livesRef.current,
                    stage: stageRef.current,
                    difficulty: difficultyRef.current,
                    achievedPolicies: [...achievedPoliciesRef.current]
                });
            };

            useEffect(() => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = CANDIDATE_IMG_PATH;
                img.onload = () => { candidateImageRef.current = img; setImageLoaded(true); };
                img.onerror = () => { setImageLoaded(false); }
            }, []);

            // --- Save Screenshot Helper ---
            const handleSaveImage = () => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 720;
                tempCanvas.height = 1280;
                const ctx = tempCanvas.getContext('2d');
                ctx.scale(2, 2);

                ctx.fillStyle = "#0f172a"; ctx.fillRect(0, 0, 360, 640);
                
                ctx.textAlign = "center";
                ctx.fillStyle = gameStateRef.current === 'STAGE_CLEAR' ? "#facc15" : "#fbbf24"; 
                ctx.font = "900 32px sans-serif";
                const title = gameStateRef.current === 'STAGE_CLEAR' ? `STAGE ${stageRef.current} ì™„ìˆ˜!` : "ë„ì „ ê²°ê³¼";
                ctx.fillText(title, 180, 80);

                ctx.fillStyle = "#ffffff";
                ctx.font = "bold 24px sans-serif";
                ctx.fillText(`${scoreRef.current}ì `, 180, 120);

                // ì‚¬ì§„
                ctx.save(); ctx.beginPath(); ctx.arc(180, 200, 50, 0, Math.PI * 2); ctx.closePath(); ctx.clip();
                if (imageLoaded && candidateImageRef.current) {
                    try { ctx.drawImage(candidateImageRef.current, 130, 150, 100, 100); } 
                    catch(e) { ctx.fillStyle = "#334155"; ctx.fillRect(130, 150, 100, 100); }
                } else {
                    ctx.fillStyle = "#334155"; ctx.fillRect(130, 150, 100, 100); 
                }
                ctx.restore();
                ctx.beginPath(); ctx.arc(180, 200, 50, 0, Math.PI * 2); ctx.lineWidth = 4; ctx.strokeStyle = "#fbbf24"; ctx.stroke();

                const policies = POLICY_LIST[(stageRef.current - 1) % POLICY_LIST.length];
                let startY = 300;
                ctx.font = "bold 16px sans-serif"; ctx.fillStyle = "#60a5fa";
                ctx.fillText(`[ ${STAGE_TITLES[(stageRef.current-1)%STAGE_TITLES.length]} ë¯¸ì…˜ ]`, 180, 280);
                ctx.textAlign = "left";
                policies.forEach((policy, i) => {
                    const text = policy.replace(/\n/g, " ");
                    const isSolved = achievedPoliciesRef.current.includes(text);
                    ctx.fillStyle = "#1e293b";
                    if (ctx.roundRect) ctx.roundRect(40, startY + (i*50), 280, 40, 8); else ctx.fillRect(40, startY + (i*50), 280, 40);
                    ctx.fill();

                    ctx.font = "bold 14px sans-serif"; ctx.fillStyle = isSolved ? "#ffffff" : "#64748b";
                    ctx.beginPath(); ctx.arc(60, startY + (i*50) + 20, 10, 0, Math.PI*2);
                    if(isSolved) {
                        ctx.fillStyle = "#22c55e"; ctx.fill(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
                        ctx.moveTo(56, startY + (i*50) + 20); ctx.lineTo(59, startY + (i*50) + 23); ctx.lineTo(64, startY + (i*50) + 17); ctx.stroke();
                    } else {
                        ctx.strokeStyle = "#64748b"; ctx.stroke();
                    }

                    ctx.fillStyle = isSolved ? "#ffffff" : "#64748b";
                    ctx.fillText(text, 85, startY + (i*50) + 25);
                    
                    if (isSolved) {
                        ctx.save(); ctx.translate(280, startY + (i*50) + 20); ctx.rotate(-0.2);
                        ctx.strokeStyle = "#ef4444"; ctx.lineWidth = 2; ctx.strokeRect(-30, -12, 60, 24);
                        ctx.fillStyle = "#ef4444"; ctx.font = "bold 12px sans-serif"; ctx.textAlign = "center";
                        ctx.fillText("ê²©íŒŒì™„ë£Œ", 0, 4); ctx.restore();
                    }
                });

                const footerY = 550;
                ctx.textAlign = "center"; ctx.fillStyle = "#3b82f6"; ctx.font = "bold 14px sans-serif";
                ctx.fillText("ìµœë³‘ê´€ê³¼ í•¨ê»˜", 180, footerY);
                ctx.font = "900 20px sans-serif"; ctx.fillStyle = "#ffffff";
                ctx.fillText("ìµì‚° ëŒ€ì „í™˜, ì§€ê¸ˆ ì‹œì‘í•©ë‹ˆë‹¤!", 180, footerY + 30);

                try {
                    const dataUrl = tempCanvas.toDataURL('image/png');
                    setResultImage(dataUrl);
                } catch(e) {
                    alert("ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ (ë³´ì•ˆ ì •ì±…). í™”ë©´ ìº¡ì²˜ë¥¼ ì´ìš©í•´ì£¼ì„¸ìš”.");
                }
            };

            const handleShareLink = async () => {
                const shareData = {
                    title: 'ìµœë³‘ê´€ì˜ ê·œì œ ê²©íŒŒ',
                    text: `ì €ëŠ” ìµœë³‘ê´€ í›„ë³´ì™€ í•¨ê»˜ ê·œì œë¥¼ ê²©íŒŒí•˜ê³  ${scoreRef.current}ì ì„ ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤! ë‹¹ì‹ ë„ ë„ì „í•´ë³´ì„¸ìš”.`,
                    url: window.location.href
                };
                if (navigator.share) {
                    try { await navigator.share(shareData); } catch (err) { console.log('Error sharing:', err); }
                } else {
                    const dummy = document.createElement('input');
                    document.body.appendChild(dummy);
                    dummy.value = window.location.href;
                    dummy.select();
                    document.execCommand('copy');
                    document.body.removeChild(dummy);
                    alert("ğŸ”— ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! ì¹´í†¡ë°©ì— ë¶™ì—¬ë„£ì–´ ê³µìœ í•´ì£¼ì„¸ìš”.");
                }
            };

            // --- Logic ---
            const initBricks = (currentStage) => {
                const newBricks = [];
                const stagePolicies = POLICY_LIST[(currentStage - 1) % POLICY_LIST.length];
                let policyIndex = 0;
                const currentRowCount = currentStage === 1 ? 3 : BRICK_ROW_COUNT;

                for (let c = 0; c < BRICK_COL_COUNT; c++) {
                    for (let r = 0; r < currentRowCount; r++) {
                        let type = 1; let hp = 1; let color = "#94a3b8"; let text = "ê·œì œ";
                        if (currentStage > 1 && r < 2) { type = 2; hp = 2; color = "#ef4444"; text = "ìœ„ê¸°"; }
                        
                        const policyRowCondition = currentStage === 1 ? r >= 0 : r > 1;
                        if (type !== 2 && policyIndex < stagePolicies.length && (policyRowCondition && Math.random() < 0.4)) {
                            type = 3; hp = 1; color = "#eab308"; text = stagePolicies[policyIndex++];
                        } else if (type === 1) { text = "ê·œì œ"; }

                        newBricks.push({ 
                            x: (c * (BRICK_WIDTH + BRICK_PADDING)) + BRICK_OFFSET_LEFT, 
                            y: (r * (BRICK_HEIGHT + BRICK_PADDING)) + BRICK_OFFSET_TOP, 
                            status: 1, type, hp, color, text
                        });
                    }
                }
                let brickIdx = 0;
                while(policyIndex < stagePolicies.length && brickIdx < newBricks.length) {
                    if(newBricks[brickIdx].type === 1) {
                        newBricks[brickIdx].type = 3; newBricks[brickIdx].color = "#eab308"; newBricks[brickIdx].text = stagePolicies[policyIndex++];
                    }
                    brickIdx++;
                }
                bricksRef.current = newBricks;
            };

            const update = () => {
                if (gameStateRef.current !== 'PLAYING') return;

                const currentPaddleWidth = paddleRef.current.width;
                if (paddleRef.current.x < 0) paddleRef.current.x = 0;
                if (paddleRef.current.x + currentPaddleWidth > WIDTH) paddleRef.current.x = WIDTH - currentPaddleWidth;

                const ball = ballRef.current;
                if (ball.active) {
                    ball.x += ball.dx; ball.y += ball.dy;
                    if (ball.x + ball.dx > WIDTH - BALL_RADIUS || ball.x + ball.dx < BALL_RADIUS) ball.dx = -ball.dx;
                    if (ball.y + ball.dy < BALL_RADIUS) ball.dy = -ball.dy;
                    else if (ball.y + ball.dy > GAME_HEIGHT - BALL_RADIUS) {
                        const newLives = livesRef.current - 1;
                        updateLives(newLives);
                        if (newLives <= 0) updateGameState('GAMEOVER');
                        else resetBall();
                    }

                    const PADDLE_Y = GAME_HEIGHT - PADDLE_HEIGHT - 5;
                    if (ball.y + BALL_RADIUS >= PADDLE_Y && ball.y - BALL_RADIUS <= PADDLE_Y + PADDLE_HEIGHT && ball.x >= paddleRef.current.x && ball.x <= paddleRef.current.x + currentPaddleWidth && ball.dy > 0) {
                        let hitPoint = ball.x - (paddleRef.current.x + currentPaddleWidth / 2);
                        hitPoint = hitPoint / (currentPaddleWidth / 2);
                        let angle = hitPoint * (Math.PI / 3);
                        let speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                        speed = Math.min(speed * 1.02, 10); 
                        ball.dx = speed * Math.sin(angle); ball.dy = -speed * Math.cos(angle); ball.y = PADDLE_Y - BALL_RADIUS;
                    }

                    let activeBricksCount = 0;
                    bricksRef.current.forEach(b => {
                        if (b.status === 1) {
                            activeBricksCount++;
                            if (ball.x > b.x && ball.x < b.x + BRICK_WIDTH && ball.y > b.y && ball.y < b.y + BRICK_HEIGHT) {
                                ball.dy = -ball.dy; b.hp -= 1;
                                for(let i=0; i<8; i++) particlesRef.current.push({ x: b.x + BRICK_WIDTH/2, y: b.y + BRICK_HEIGHT/2, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 1.0, color: b.color });
                                
                                if (b.hp <= 0) {
                                    b.status = 0;
                                    updateScore(scoreRef.current + (b.type === 3 ? 100 : 10));
                                    if (b.type === 3) {
                                        floatingTextsRef.current.push({ x: b.x + BRICK_WIDTH/2, y: b.y, text: "ê³µì•½ ì‹¤í˜„!", color: "#eab308", life: 1.0 });
                                        const policyText = b.text.replace(/\n/g, " ");
                                        addAchievedPolicy(policyText);
                                        itemsRef.current.push({ x: b.x + BRICK_WIDTH/2, y: b.y + BRICK_HEIGHT/2, type: 'BUDGET', active: true });
                                    } else if (Math.random() < 0.1) {
                                        itemsRef.current.push({ x: b.x + BRICK_WIDTH/2, y: b.y + BRICK_HEIGHT/2, type: 'NOTEBOOK', active: true });
                                    }
                                }
                            }
                        }
                    });
                    if (activeBricksCount === 0) { 
                        ball.active = false; 
                        updateGameState('STAGE_CLEAR');
                    }
                }

                itemsRef.current.forEach(item => {
                    item.y += 2;
                    const PADDLE_Y = GAME_HEIGHT - PADDLE_HEIGHT - 5;
                    if (item.active && item.y >= PADDLE_Y && item.y <= GAME_HEIGHT && item.x >= paddleRef.current.x && item.x <= paddleRef.current.x + currentPaddleWidth) {
                        item.active = false;
                        if (item.type === 'NOTEBOOK') updateScore(scoreRef.current + 100);
                        else if (item.type === 'BUDGET') updateScore(scoreRef.current + 500);
                    }
                });
                itemsRef.current = itemsRef.current.filter(i => i.active && i.y < GAME_HEIGHT);
                floatingTextsRef.current.forEach(t => { t.y -= 1; t.life -= 0.02; });
                floatingTextsRef.current = floatingTextsRef.current.filter(t => t.life > 0);
                particlesRef.current.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
                particlesRef.current = particlesRef.current.filter(p => p.life > 0);
            };

            const resetBall = () => {
                const settings = DIFFICULTY_SETTINGS[difficultyRef.current];
                let currentSpeed = stageRef.current === 1 ? 2.0 : settings.speed;
                const dirX = Math.random() > 0.5 ? currentSpeed : -currentSpeed;
                ballRef.current = { x: WIDTH / 2, y: GAME_HEIGHT - 30, dx: dirX, dy: -currentSpeed, speedBase: currentSpeed, active: false };
            };

            const startGame = () => {
                const settings = DIFFICULTY_SETTINGS[difficultyRef.current];
                paddleRef.current.width = settings.paddleWidth;
                initBricks(stageRef.current);
                resetBall();
                ballRef.current.active = true;
                updateGameState('PLAYING');
            };

            const startStageIntro = () => {
                scoreRef.current = 0;
                livesRef.current = DIFFICULTY_SETTINGS[difficultyRef.current].lives;
                stageRef.current = 1;
                achievedPoliciesRef.current = [];
                updateGameState('STAGE_INTRO');
            };

            const nextStage = () => {
                stageRef.current += 1;
                updateGameState('STAGE_INTRO');
            };

            const render = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, WIDTH, HEIGHT);

                ctx.fillStyle = "#0f172a"; ctx.fillRect(0, 0, WIDTH, GAME_HEIGHT);
                const grad = ctx.createLinearGradient(0, GAME_HEIGHT, 0, HEIGHT);
                grad.addColorStop(0, "#1e3a8a"); grad.addColorStop(1, "#172554");
                ctx.fillStyle = grad; ctx.fillRect(0, GAME_HEIGHT, WIDTH, CONTROL_HEIGHT);
                ctx.beginPath(); ctx.moveTo(0, GAME_HEIGHT); ctx.lineTo(WIDTH, GAME_HEIGHT); ctx.strokeStyle = "#3b82f6"; ctx.lineWidth = 2; ctx.stroke();
                
                ctx.fillStyle = "#bfdbfe"; ctx.font = "bold 14px sans-serif"; ctx.textAlign = "center"; ctx.fillText("ì´ê³³ì„ í„°ì¹˜í•´ì„œ ì¢Œìš°ë¡œ ì›€ì§ì´ì„¸ìš”", WIDTH/2, GAME_HEIGHT + 35);
                ctx.fillStyle = "#ffffff"; ctx.font = "bold 18px sans-serif";
                ctx.fillText("ìµœë³‘ê´€ê³¼ í•¨ê»˜ ìµì‚° ë°œì „í•˜ê¸°", WIDTH/2, GAME_HEIGHT + 65);

                if (gameStateRef.current === 'PLAYING') {
                    ctx.fillStyle = "#fff"; ctx.font = "bold 14px sans-serif"; ctx.textAlign = "center";
                    const stageTitle = STAGE_TITLES[(stageRef.current - 1) % STAGE_TITLES.length];
                    ctx.fillText(`STAGE ${stageRef.current}: ${stageTitle}`, WIDTH/2, BRICK_OFFSET_TOP - 20);
                }

                bricksRef.current.forEach(b => {
                    if (b.status === 1) {
                        ctx.beginPath(); ctx.rect(b.x, b.y, BRICK_WIDTH, BRICK_HEIGHT); ctx.fillStyle = b.color; ctx.fill(); ctx.strokeStyle = "rgba(0,0,0,0.2)"; ctx.stroke(); ctx.closePath();
                        ctx.fillStyle = b.type === 2 ? "#fff" : "#1e293b"; ctx.font = b.type === 3 ? "bold 11px sans-serif" : "10px sans-serif";
                        ctx.textAlign = "center"; ctx.textBaseline = "middle";
                        const lines = b.text.split('\n'); const lineHeight = 12; const startY = b.y + BRICK_HEIGHT/2 - ((lines.length - 1) * lineHeight) / 2;
                        lines.forEach((line, i) => { ctx.fillText(line, b.x + BRICK_WIDTH/2, startY + (i * lineHeight)); });
                    }
                });

                const PADDLE_Y = GAME_HEIGHT - PADDLE_HEIGHT - 5;
                if (ctx.roundRect) { ctx.beginPath(); ctx.roundRect(paddleRef.current.x, PADDLE_Y, paddleRef.current.width, PADDLE_HEIGHT, 5); ctx.fillStyle = "#2563eb"; ctx.fill(); ctx.closePath(); } 
                else { ctx.fillStyle = "#2563eb"; ctx.fillRect(paddleRef.current.x, PADDLE_Y, paddleRef.current.width, PADDLE_HEIGHT); }

                if (candidateImageRef.current && imageLoaded) {
                    const FACE_SIZE = 30; const FACE_X = paddleRef.current.x + (paddleRef.current.width - FACE_SIZE) / 2; const FACE_Y = PADDLE_Y - FACE_SIZE + 5; 
                    ctx.save(); ctx.beginPath(); ctx.arc(FACE_X + FACE_SIZE/2, FACE_Y + FACE_SIZE/2, FACE_SIZE/2, 0, Math.PI * 2); ctx.closePath(); ctx.clip(); 
                    ctx.drawImage(candidateImageRef.current, FACE_X, FACE_Y, FACE_SIZE, FACE_SIZE); ctx.restore();
                    ctx.beginPath(); ctx.arc(FACE_X + FACE_SIZE/2, FACE_Y + FACE_SIZE/2, FACE_SIZE/2, 0, Math.PI * 2); ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke();
                } else {
                    ctx.fillStyle = "#fff"; ctx.font = "bold 10px sans-serif"; ctx.textAlign = "center"; ctx.fillText("ìµœë³‘ê´€", paddleRef.current.x + paddleRef.current.width/2, PADDLE_Y + 11);
                }

                const ball = ballRef.current;
                if (gameStateRef.current !== 'STAGE_CLEAR' && gameStateRef.current !== 'STAGE_INTRO') {
                    ctx.beginPath(); ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2); ctx.fillStyle = "#fbbf24"; ctx.fill(); ctx.closePath();
                }
                itemsRef.current.forEach(item => { ctx.beginPath(); ctx.arc(item.x, item.y, 10, 0, Math.PI*2); ctx.fillStyle = item.type === 'NOTEBOOK' ? "#3b82f6" : "#eab308"; ctx.fill(); ctx.fillStyle = "#fff"; ctx.font = "9px sans-serif"; ctx.fillText(item.type === 'NOTEBOOK' ? "ìˆ˜ì²©" : "ì˜ˆì‚°", item.x, item.y + 3); });
                particlesRef.current.forEach(p => { ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fillStyle = p.color; ctx.fill(); ctx.globalAlpha = 1.0; });
                floatingTextsRef.current.forEach(t => { ctx.globalAlpha = t.life; ctx.fillStyle = t.color; ctx.font = "bold 16px sans-serif"; ctx.strokeStyle = "#000"; ctx.lineWidth = 2; ctx.strokeText(t.text, t.x, t.y); ctx.fillText(t.text, t.x, t.y); ctx.globalAlpha = 1.0; });
            };

            const gameLoop = () => { update(); render(); requestIdRef.current = requestAnimationFrame(gameLoop); };
            useEffect(() => { 
                requestIdRef.current = requestAnimationFrame(gameLoop); 
                return () => cancelAnimationFrame(requestIdRef.current); 
            }, []);

            const handleTouchMove = (e) => {
                if (gameStateRef.current !== 'PLAYING') return;
                const rect = canvasRef.current.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                paddleRef.current.x = touchX - paddleRef.current.width / 2;
            };
            const handleMouseMove = (e) => {
                if (gameStateRef.current !== 'PLAYING') return;
                const rect = canvasRef.current.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                paddleRef.current.x = mouseX - paddleRef.current.width / 2;
            };
            const launchBall = () => { if (gameStateRef.current === 'PLAYING' && !ballRef.current.active) ballRef.current.active = true; };

            return (
                <div className="flex flex-col items-center justify-center min-h-screen bg-slate-900 font-sans p-4 touch-none select-none">
                    <div className="w-full max-w-[360px] flex justify-between items-center mb-2 text-white">
                        <div className="flex gap-4">
                            <div><p className="text-[10px] text-slate-400">SCORE</p><p className="text-xl font-mono font-bold text-yellow-400">{uiState.score}</p></div>
                            <div><p className="text-[10px] text-slate-400">STAGE</p><p className="text-xl font-mono font-bold">{uiState.stage}</p></div>
                        </div>
                        <div className="flex gap-1">{[...Array(uiState.lives)].map((_, i) => (<div key={i} className="w-4 h-4 bg-red-500 rounded-full"></div>))}</div>
                    </div>

                    <div className="relative bg-slate-800 rounded-xl overflow-hidden shadow-2xl border-4 border-slate-700">
                        <canvas ref={canvasRef} width={WIDTH} height={HEIGHT} className="cursor-none touch-none" onTouchMove={handleTouchMove} onMouseMove={handleMouseMove} onClick={launchBall}/>

                        {uiState.gameState === 'START' && (
                            <div className="absolute inset-0 bg-slate-900/90 flex flex-col items-center justify-center text-white text-center p-6" style={{height: `${GAME_HEIGHT}px`}}>
                                <Zap className="w-20 h-20 text-yellow-400 mb-4 animate-pulse" />
                                <h1 className="text-2xl font-black mb-1">ê·œì œ ê²©íŒŒ</h1>
                                <p className="text-blue-300 font-bold mb-4 text-sm">"ìµœë³‘ê´€ì˜ ì •ì±…ìœ¼ë¡œ ìµì‚°ì„ ëš«ì–´ë¼!"</p>
                                <div className="bg-white/10 p-3 rounded-lg w-full mb-4">
                                    <p className="text-xs text-slate-300 mb-2 font-bold">ë‚œì´ë„ ì„ íƒ</p>
                                    <div className="flex gap-2 justify-center">
                                        {Object.keys(DIFFICULTY_SETTINGS).map((key) => (
                                            <button key={key} onClick={() => { difficultyRef.current = key; forceUpdate(); }} className={`flex-1 py-2 rounded font-bold text-xs border-2 transition-all ${uiState.difficulty === key ? `${DIFFICULTY_SETTINGS[key].color} border-white text-white scale-105` : 'bg-slate-700 border-transparent text-slate-400'}`}>
                                                {DIFFICULTY_SETTINGS[key].label}
                                            </button>
                                        ))}
                                    </div>
                                    <p className={`text-[10px] mt-2 ${DIFFICULTY_SETTINGS[uiState.difficulty].text}`}>* {uiState.difficulty === 'EASY' ? "ì²œì²œíˆ ì¦ê¸°ì„¸ìš”" : uiState.difficulty === 'NORMAL' ? "í‘œì¤€ ì†ë„" : "ë§¤ìš° ë¹ ë¦„!"}</p>
                                </div>
                                {/* [ìˆ˜ì •] ë²„íŠ¼ í™œì„±í™”: animate-pulse ì œê±°, z-30 ì¶”ê°€, opacity íš¨ê³¼ ì œê±° */}
                                <div className="flex flex-col gap-2 w-full max-w-[200px] relative z-30">
                                    <button 
                                        onClick={startStageIntro} 
                                        className="bg-blue-600 hover:bg-blue-500 px-6 py-3 rounded-full font-bold shadow-lg flex items-center justify-center text-sm transition-transform active:scale-95 cursor-pointer"
                                    >
                                        <Play className="mr-2 inline w-4 h-4" /> ì¶œë™í•˜ê¸°
                                    </button>
                                </div>
                            </div>
                        )}

                        {uiState.gameState === 'STAGE_INTRO' && (
                            <div className="absolute inset-0 bg-slate-900/95 flex flex-col items-center justify-center text-white text-center p-6" style={{height: `${GAME_HEIGHT}px`}}>
                                <Target className="w-16 h-16 text-blue-400 mb-4 animate-pulse" />
                                <h2 className="text-2xl font-black text-yellow-400 mb-1">STAGE {uiState.stage}</h2>
                                <h3 className="text-xl font-bold text-white mb-6">{STAGE_TITLES[(uiState.stage - 1) % STAGE_TITLES.length]}</h3>
                                <div className="bg-blue-900/50 p-5 rounded-xl w-full max-w-xs mb-8 border border-blue-500/30">
                                    <p className="text-xs text-blue-300 font-bold mb-4 border-b border-blue-500/30 pb-2">ì´ë²ˆ ìŠ¤í…Œì´ì§€ í•µì‹¬ ê³µì•½</p>
                                    <div className="space-y-3 text-left">
                                        {POLICY_LIST[(uiState.stage - 1) % POLICY_LIST.length].map((policy, idx) => (
                                            <div key={idx} className="flex items-center text-base font-bold"><CheckCircle className="w-5 h-5 text-yellow-400 mr-3 flex-shrink-0" />{policy.replace(/\n/g, " ")}</div>
                                        ))}
                                    </div>
                                </div>
                                <button onClick={startGame} className="bg-yellow-500 text-black px-8 py-3 rounded-full font-black shadow-lg flex items-center justify-center hover:bg-yellow-400 transition-colors animate-pulse">ì‘ì „ ê°œì‹œ <ArrowRight className="ml-2 w-5 h-5"/></button>
                            </div>
                        )}

                        {resultImage && (
                            <div className="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center p-4">
                                <p className="text-white text-lg font-bold mb-4 animate-pulse text-center">{/iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? "ì´ë¯¸ì§€ë¥¼ ê¸¸ê²Œ ëˆŒëŸ¬ ì €ì¥í•˜ì„¸ìš”!" : "ì´ë¯¸ì§€ë¥¼ ìš°í´ë¦­í•˜ì—¬ ì €ì¥í•˜ì„¸ìš”!"}</p>
                                <img src={resultImage} alt="ê²°ê³¼ ì¸ì¦ì„œ" className="max-w-full max-h-[70vh] border-4 border-white rounded-lg shadow-lg mb-4" />
                                <button onClick={() => setResultImage(null)} className="bg-slate-600 hover:bg-slate-500 text-white px-8 py-3 rounded-full font-bold transition-colors">ë‹«ê¸°</button>
                            </div>
                        )}

                        {uiState.gameState === 'STAGE_CLEAR' && (
                            <div className="absolute inset-0 bg-slate-900/95 flex flex-col items-center justify-center text-white text-center p-6 animate-fade-in" style={{height: `${GAME_HEIGHT}px`}}>
                                <CheckCircle className="w-16 h-16 text-green-400 mb-4" />
                                <h2 className="text-2xl font-black text-yellow-400 mb-2">ìŠ¤í…Œì´ì§€ {uiState.stage} ì™„ìˆ˜!</h2>
                                <p className="text-slate-300 text-sm mb-6">ê·œì œì™€ ìœ„ê¸°ë¥¼ í›Œë¥­í•˜ê²Œ ê²©íŒŒí•˜ì…¨ìŠµë‹ˆë‹¤.</p>
                                <div className="bg-white/10 p-4 rounded-xl w-full max-w-xs mb-6 border border-white/20">
                                    <p className="text-xs text-blue-300 font-bold mb-3 border-b border-white/10 pb-2">ì •ì±… ë‹¬ì„± í˜„í™©</p>
                                    <div className="space-y-2">
                                        {POLICY_LIST[(uiState.stage - 1) % POLICY_LIST.length].map((policy, idx) => {
                                            const text = policy.replace(/\n/g, " ");
                                            const isSolved = achievedPoliciesRef.current.includes(text);
                                            return (
                                                <div key={idx} className="flex justify-between items-center text-sm font-bold">
                                                    <span className={isSolved ? "text-white" : "text-slate-500"}>{text}</span>
                                                    <span className={isSolved ? "text-green-400" : "text-red-400"}>{isSolved ? "í•´ê²°âœ…" : "ë¯¸í•´ê²°âŒ"}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                <div className="flex gap-2 w-full max-w-xs justify-center mb-4"><button onClick={nextStage} className="bg-blue-600 px-6 py-3 rounded-full font-bold shadow-lg flex items-center justify-center hover:bg-blue-500 transition-colors text-sm w-full">ë‹¤ìŒ ì§€ì—­ ì´ë™ <ArrowRight className="ml-2 w-4 h-4"/></button></div>
                                <div className="flex gap-2 w-full max-w-xs justify-center">
                                    <button onClick={handleSaveImage} className="bg-slate-700 px-3 py-3 rounded-full font-bold shadow-lg flex-1 flex items-center justify-center hover:bg-slate-600 text-xs"><Camera size={14} className="mr-1"/> ì •ì±…ë‹¬ì„± ìë‘í•˜ê¸°</button>
                                    <button onClick={handleShareLink} className="bg-yellow-600 text-white px-3 py-3 rounded-full font-bold shadow-lg flex-1 flex items-center justify-center hover:bg-yellow-500 text-xs"><Share2 size={14} className="mr-1"/> ì¹œêµ¬ì—ê²Œ ê³µìœ </button>
                                </div>
                            </div>
                        )}

                        {uiState.gameState === 'GAMEOVER' && (
                            <div className="absolute inset-0 bg-slate-900/90 flex flex-col items-center justify-center text-white text-center p-6" style={{height: `${GAME_HEIGHT}px`}}>
                                <h1 className="text-3xl font-black text-red-500 mb-2">ê²Œì„ ì¢…ë£Œ</h1>
                                <p className="text-slate-400 mb-4">ë„ì „ì´ ë©ˆì·„ì§€ë§Œ, í¬ë§ì€ ê³„ì†ë©ë‹ˆë‹¤.</p>
                                <div className="bg-white/10 p-4 rounded-xl w-full max-w-xs mb-6 border border-white/20">
                                    <p className="text-xs text-blue-300 font-bold mb-3 border-b border-white/10 pb-2">ì •ì±… ë‹¬ì„± í˜„í™© (Stage {uiState.stage})</p>
                                    <div className="space-y-2">
                                        {POLICY_LIST[(uiState.stage - 1) % POLICY_LIST.length].map((policy, idx) => {
                                            const text = policy.replace(/\n/g, " ");
                                            const isSolved = achievedPoliciesRef.current.includes(text);
                                            return (
                                                <div key={idx} className="flex justify-between items-center text-sm font-bold">
                                                    <span className={isSolved ? "text-white" : "text-slate-500"}>{text}</span>
                                                    <span className={isSolved ? "text-green-400" : "text-red-400"}>{isSolved ? "í•´ê²°âœ…" : "ë¯¸í•´ê²°âŒ"}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                                <div className="flex gap-2 w-full justify-center mb-2"><button onClick={() => { setScore(0); setLives(DIFFICULTY_SETTINGS[difficultyRef.current].lives); setStage(1); setAchievedPolicies([]); updateGameState('STAGE_INTRO'); }} className="bg-yellow-500 text-black px-6 py-3 rounded-lg font-bold flex items-center shadow-lg hover:bg-yellow-400 text-sm w-full justify-center"><RotateCcw size={16} className="mr-2"/>ìµœë³‘ê´€ê³¼ í•¨ê»˜ ì¬ë„ì „</button></div>
                                <div className="flex gap-2 w-full justify-center">
                                    <button onClick={handleSaveImage} className="bg-slate-700 text-white px-3 py-3 rounded-lg font-bold flex flex-1 items-center justify-center shadow-lg hover:bg-slate-600 text-xs"><Camera size={14} className="mr-1"/> ê²°ê³¼ ìë‘í•˜ê¸°</button>
                                    <button onClick={handleShareLink} className="bg-yellow-600 text-white px-3 py-3 rounded-lg font-bold flex flex-1 items-center justify-center shadow-lg hover:bg-yellow-500 text-xs"><Share2 size={14} className="mr-1"/> ì¹œêµ¬ì—ê²Œ ê³µìœ </button>
                                </div>
                            </div>
                        )}
                        
                        {uiState.gameState === 'PLAYING' && !ballRef.current.active && (
                            <div className="absolute left-0 w-full text-center text-white/50 text-sm animate-pulse pointer-events-none" style={{top: `${GAME_HEIGHT/2}px`}}>í„°ì¹˜í•´ì„œ ë°œì‚¬!</div>
                        )}
                    </div>
                    <div className="mt-4 text-center text-xs text-slate-500"><p>íšŒìƒ‰ ê·œì œì™€ ë¹¨ê°„ ìœ„ê¸°ë¥¼ ê¹¨ê³ , ë…¸ë€ ê³µì•½ì„ ì‹¤í˜„í•˜ì„¸ìš”!</p></div>
                </div>
            );
        };

        // --- App (Main) ---
        const App = () => {
            const [mode, setMode] = useState('INTRO');
            return (
                <React.Fragment>
                    {mode === 'INTRO' && <IntroScreen onStart={() => setMode('GAME')} />}
                    {mode === 'GAME' && <GameScreen onBackToIntro={() => setMode('INTRO')} />}
                </React.Fragment>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
